<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge,chrome=1"><title>7.类的继承 | 一个分享学习笔记的网站</title><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content><meta name=generator content="Hugo 0.152.2"><meta name=robots content="index, follow"><link rel=stylesheet href=/ananke/css/main.min.efe4d852f731d5d1fbb87718387202a97aafd768cdcdaed0662bbe6982e91824.css><link rel=canonical href=https://wrongtrojan.github.io/7.%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF/><meta property="og:url" content="https://wrongtrojan.github.io/7.%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF/"><meta property="og:site_name" content="一个分享学习笔记的网站"><meta property="og:title" content="7.类的继承"><meta property="og:description" content="Welcome to this website"><meta property="og:locale" content="zh_cn"><meta property="og:type" content="article"><meta property="article:published_time" content="2025-01-23T00:00:00+00:00"><meta property="article:modified_time" content="2025-01-23T00:00:00+00:00"><meta itemprop=name content="7.类的继承"><meta itemprop=description content="Welcome to this website"><meta itemprop=datePublished content="2025-01-23T00:00:00+00:00"><meta itemprop=dateModified content="2025-01-23T00:00:00+00:00"><meta itemprop=wordCount content="97"><meta itemprop=keywords content="程序设计,程序设计"><meta name=twitter:card content="summary"><meta name=twitter:title content="7.类的继承"><meta name=twitter:description content="Welcome to this website"></head><body class="ma0 avenir bg-near-white production"><header><div class=bg-black><nav class="pv3 ph3 ph4-ns" role=navigation><div class="flex-l center items-center justify-between"><a href=/ class="f3 fw2 hover-white white-90 dib no-underline">一个分享学习笔记的网站</a><div class="flex-l items-center"><ul class="pl0 mr3"><li class="list f5 f4-ns fw4 dib pr3"><a class="hover-white white-90 no-underline" href=/ title="首页 page">首页</a></li><li class="list f5 f4-ns fw4 dib pr3"><a class="hover-white white-90 no-underline" href=/about/ title="关于 page">关于</a></li></ul><div class=ananke-socials></div></div></div></nav></div></header><main class=pb7 role=main><article class="flex-l mw8 center ph3 flex-wrap justify-between"><header class="mt4 w-100"><aside class="instapaper_ignoref b helvetica tracked ttu"></aside><div id=sharing class="mt3 ananke-socials"></div><h1 class="f1 athelas mt3 mb1">7.类的继承</h1><time class="f6 mv4 dib tracked" datetime=2025-01-23T00:00:00Z>January 23, 2025</time></header><div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-two-thirds-l"><p><strong>类的继承</strong></p><p><strong>基类与派生类</strong></p><blockquote><p>类的继承，是新的类从已有类得到已有的特性</p><p>从已有类产生新类的过程就是类的派生</p><p>已有的类称为基类或父类，新类称为派生类或子类</p></blockquote><p><strong>派生类的定义</strong></p><blockquote><p>class 派生类名：继承方式 基类名列表{ 派生类成员声明; };</p><p>一个派生类可以有多个基类，称为多继承；也可以只有一个直接基类，称为单继承</p><p>类族中直接派生出某类的基类称为直接基类，基类的基类或更高层称为间接基类</p><p>继承方式规定了如何访问从基类继承的成，系统默认为私有继承</p><p>派生类成员是指除了基类继承来的成员外新增加的数据和函数成员</p></blockquote><p><strong>派生类生成过程</strong></p><blockquote><p><strong>吸收基类成员</strong></p><pre><code>派生类不包含基类的构造函数和析构函数
</code></pre></blockquote><blockquote><p><strong>改造基类成员</strong></p><pre><code>基类成员的访问控制问题

  主要依靠派生类定义时继承方式控制

基类成员的覆盖或隐藏

  成员覆盖

    在第八章介绍

  成员隐藏

    派生类中声明和基类数据或函数成员同名的新成员即同名隐藏
</code></pre><p><strong>添加新的成员</strong></p><pre><code>加入新的适当的数据和函数成员

实现特别的初始化和扫尾工作需加入新构造函数和析构函数
</code></pre></blockquote><p><strong>继承访问控制</strong></p><blockquote><p>派生类继承了基类除构造、析构函数的所有成员，但成员访问属性可以调整</p></blockquote><blockquote><p><strong>公有继承(public)</strong></p><pre><code>基类的公有和保护成员在派生类访问属性不变，基类的私有成员不可直接访问
</code></pre></blockquote><blockquote><p><strong>私有继承(private)</strong></p><pre><code>基类的公有和保护成员变为派生类私有成员，基类的私有成员不可直接访问

进一步派生时，基类全部成员无法被直接访问，终止了基类功能的继续派生
</code></pre></blockquote><blockquote><p><strong>保护继承(protected)</strong></p><pre><code>基类的公有和保护成员变为派生类保护成员，基类的私有成员不可直接访问
</code></pre></blockquote><p><strong>类型兼容规则</strong></p><blockquote><p><strong>公有派生类的对象替代基类对象</strong></p><pre><code>派生类对象可以隐含转换临时基类对象(基类有复制/移动构造函数时)

派生类的对象可以初始化基类的引用

派生类的指针可以隐含转换为基类的指针

替代之后，派生类对象可作为基类对象使用，但只能使用从基类继承的成员

*对象依旧是原来的派生类对象
</code></pre></blockquote><p><strong>派生类构造函数与析构函数</strong></p><blockquote><p><strong>构造函数</strong></p><pre><code>构造派生类对象时，要对基类成员对象和新增成员对象进行初始化

派生类::派生类名(参数表): 基类名表(参数表),新成员对象表(参数表){}

对基类初始化需调有形参表构造函数时，派生类必须声明构造函数
</code></pre></blockquote><blockquote><p><strong>复制构造函数</strong></p><pre><code>派生类::派生类名(const 派生类名 &amp;v): 基类名(v){\...} //类型兼容规则发挥作用
</code></pre></blockquote><blockquote><p><strong>析构函数</strong></p><pre><code>与没有继承关系的类中析构函数的声明方法完全相同
</code></pre></blockquote><blockquote><p><strong>delete构造函数</strong></p><pre><code>在基类中删除的构造函数在派生类中也对应是删除状态

编译器无法执行派生类中基类部分对应的构造或赋值操作
</code></pre></blockquote><p><strong>派生类成员的标识与访问</strong></p><blockquote><p><strong>成员按访问属性划分</strong></p><pre><code>不可访问成员 私有成员 保护成员 公有成员

唯一标识问题和可见性问题 访问一个能够唯一标识的可见成员
</code></pre></blockquote><blockquote><p><strong>作用域分辨符 &ldquo;::&rdquo;</strong></p><pre><code>可见性原则：外层声明的标识符如果在内层无同名标识符则可见，反之不可见

隐藏规则与同名成员处理

  派生类声明与基类同名成员，会隐藏基类同名成员，直接访问到派生类成员

  派生类声明与基类同名函数，基类重载会被隐藏，需 &quot;::&quot; 访问基类版本。

多继承下同名成员访问

  派生类的多基类有同名成员，派生类无同名成员，需用基类名::成员名标识

  派生类有同名成员，则隐藏基类同名成员，基类成员需基类名::成员名访问

解决二义性的补充方法

  可通过using关键字将基类成员引入派生类作用域，明确成员归属

  也可用于让基类同名但参数不同的函数不被隐藏，实现重载共存

共同基类的处理

  多直接基类来自共同基类，同名成员需直接基类名加作用域分辨符唯一标识
</code></pre></blockquote><p><strong>虚基类</strong></p><blockquote><p>将共同基类设置为虚基类，从不同路径继承过来的同名成员在内存只有一个</p><p>class 派生类名: virtual 继承方式 基类名</p></blockquote><p><strong>虚基类及其派生类构造函数</strong></p><blockquote><p>虚基类无默认构造函数而有带形参构造函数则无法使用自动生成的默认构造函数</p><p>此时需在派生类构造函数初始化表中列出虚基类初始化</p><p><strong>构造一个类的一般顺序</strong></p></blockquote><ul class=pa0></ul><div class="mt6 instapaper_ignoref"></div></div><aside class="w-30-l mt6-l"></aside></article></main><footer class="bg-black bottom-0 w-100 pa3" role=contentinfo><div class="flex justify-between"><a class="f4 fw4 hover-white white-70 dn dib-ns pv2 ph3 no-underline" href=https://wrongtrojan.github.io/>&copy; 一个分享学习笔记的网站 2025</a><div><div class=ananke-socials></div></div></div></footer></body></html>