<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge,chrome=1"><title>6.数组、指针与字符串 | 一个分享学习笔记的网站</title><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content><meta name=generator content="Hugo 0.152.2"><meta name=robots content="index, follow"><link rel=stylesheet href=/ananke/css/main.min.efe4d852f731d5d1fbb87718387202a97aafd768cdcdaed0662bbe6982e91824.css><link rel=canonical href=https://wrongtrojan.github.io/6.%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/><meta property="og:url" content="https://wrongtrojan.github.io/6.%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/"><meta property="og:site_name" content="一个分享学习笔记的网站"><meta property="og:title" content="6.数组、指针与字符串"><meta property="og:description" content="Welcome to this website"><meta property="og:locale" content="zh_cn"><meta property="og:type" content="article"><meta property="article:published_time" content="2025-11-24T00:00:00+00:00"><meta property="article:modified_time" content="2025-11-24T00:00:00+00:00"><meta itemprop=name content="6.数组、指针与字符串"><meta itemprop=description content="Welcome to this website"><meta itemprop=datePublished content="2025-11-24T00:00:00+00:00"><meta itemprop=dateModified content="2025-11-24T00:00:00+00:00"><meta itemprop=wordCount content="336"><meta itemprop=keywords content="程序设计,程序设计"><meta name=twitter:card content="summary"><meta name=twitter:title content="6.数组、指针与字符串"><meta name=twitter:description content="Welcome to this website"></head><body class="ma0 avenir bg-near-white production"><header><div class=bg-black><nav class="pv3 ph3 ph4-ns" role=navigation><div class="flex-l center items-center justify-between"><a href=/ class="f3 fw2 hover-white white-90 dib no-underline">一个分享学习笔记的网站</a><div class="flex-l items-center"><ul class="pl0 mr3"><li class="list f5 f4-ns fw4 dib pr3"><a class="hover-white white-90 no-underline" href=/ title="首页 page">首页</a></li><li class="list f5 f4-ns fw4 dib pr3"><a class="hover-white white-90 no-underline" href=/about/ title="关于 page">关于</a></li></ul><div class=ananke-socials></div></div></div></nav></div></header><main class=pb7 role=main><article class="flex-l mw8 center ph3 flex-wrap justify-between"><header class="mt4 w-100"><aside class="instapaper_ignoref b helvetica tracked ttu"></aside><div id=sharing class="mt3 ananke-socials"></div><h1 class="f1 athelas mt3 mb1">6.数组、指针与字符串</h1><time class="f6 mv4 dib tracked" datetime=2025-11-24T00:00:00Z>November 24, 2025</time></header><div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-two-thirds-l"><p><strong>数组、指针与字符串</strong></p><p><strong>数组</strong></p><blockquote><p>具有一定顺序关系的对象集合体，组成数组的对象是数组的元素</p><p>每个元素有n个下标的数组称为n维数组</p></blockquote><blockquote><p><strong>数组的声明</strong></p><pre><code>数据类型 标识符[][]...[];
</code></pre></blockquote><blockquote><p><strong>数组的使用</strong></p><pre><code>通过下标来访问数组中的元素(下标必须为整数且不得越界)
</code></pre></blockquote><blockquote><p><strong>数组的存储</strong></p><pre><code>数组元素在内存中是顺序、连续存储的(包括多维数组)
</code></pre></blockquote><blockquote><p><strong>数组的初始化</strong></p><pre><code>在声明数组时给部分或全部元素赋初值

如果列出全部元素初值，可以不做元素个数说明

多维数组可以按第一维进行分组，用括号将每一组括起来

数组也可以被声明为常量
</code></pre></blockquote><blockquote><p><strong>数组作为函数参数</strong></p><pre><code>使用数组名传递数据时，传递的是地址

形参数组和实参数组的首地址重合，后面元素各自对应
</code></pre></blockquote><blockquote><p><strong>对象数组</strong></p><pre><code>数组的元素也可以是自定义类型

通过对象数组[下标].member可以访问公共成员
</code></pre></blockquote><p><strong>指针</strong></p><blockquote><p><strong>内存空间的访问方式</strong></p><pre><code>计算机的内存储器被划分为存储单元按一定规则编号，即为地址

地址编码的最基本单位是字节，每字节由8个二进制位组成

Cpp程序中通过变量名和地址利用内存单元存取数据

不传递变量的值，只传递变量得地址可以减小系统开销
</code></pre></blockquote><blockquote><p><strong>指针变量的声明</strong></p><pre><code>指针变量是用于存放内存单元地址的

数据类型 *标识符(这里的*表征声明指针);

指针可以指向各种类型，包括基本类型、数组(数组元素)、函数、对象、指针
</code></pre></blockquote><blockquote><p><strong>与地址相关的运算 &ldquo;*&rdquo; and &ldquo;&&rdquo;</strong></p><pre><code>&quot;*&quot; 指针运算符(解析运算符)

  表示获取指针所指向的变量的值，是一元操作符

&quot;&amp;&quot; 取地址运算符

  得到一个对象的地址，也是一元运算符

* &quot;&amp;&quot;出现在变量声明左边时，表示声明引用；

  出现在等号右边或执行语句时表示取地址
</code></pre></blockquote><blockquote><p><strong>指针的赋值</strong></p><pre><code>定义指针时进行初始化赋值，或者定义后单独使用赋值语句

多个指针可以指向同一个变量，一个指针只能指向一个变量

数组名称实际上是一个不能赋值的指针常量

指向常量的指针

  const 类型 \*p;

  指针指向的值不能通过指针改变，但指针本身可以改变指向另一个对象

指针类型的常量

  类型 \* const p;

  指针本身的值不能改变，指向某个固定的对象

  一般指针的值只能赋给同类型指针，但void类型可以储存任何类型对象地址

  void指针一般只在指针指向对象不确定时使用
</code></pre></blockquote><blockquote><p><strong>指针运算</strong></p><pre><code>指针是一种数据类型，可以参与部分运算(算术运算、关系运算和赋值运算)

算术运算

  指针可以和整数做加减法运算，表达指针指向位置后移或前移

  如(pl+nl)(或pl\[nl\])表示pl指向位置后移nl个数(nl\*typebyte个字节)

  一般指针的算术运算和数组使用相联系，避免破坏地址数据或代码

关系运算

  指向相同类型数据的指针之间进行的关系运算

  两个指针相等，表示两个指针指向同一个地址

  指针变量可以和整数0进行比较，0专用于表示空指针

  空指针不指向任何有效地址
</code></pre></blockquote><blockquote><p><strong>用指针处理数组元素</strong></p><pre><code>begin和end

  begin返回指向数组首元素的指针

  end返回返回指向数组尾元素下一元素的指针

  这两个函数定义在iterator头文件
</code></pre></blockquote><blockquote><p><strong>指针数组</strong></p><pre><code>元素都是指针变量的数组，每个元素必须是同一类型的指针

数据类型 \*pa\[下标\]；

可以用数组初始化指针数组，元素为数组首地址
</code></pre></blockquote><blockquote><p><strong>指针作为函数参数</strong></p><pre><code>在不同函数之间传递大量数据时程序开销非常大

如果传递数据存放在连续内存区域中，可以只传递数据的起始地址

指针作为函数的形参有三个作用

  使实参与形参指向共同内存空间，达到参数双向传递

  减少函数调用时数据传递的开销(一般会使用引用，部分使用指针)

  通过指向函数的指针传递函数代码的首地址
</code></pre></blockquote><blockquote><p><strong>指针型函数</strong></p><pre><code>指针也可以是函数的返回值，返回值为指针的函数即为指针型函数

在函数结束时把大量的数据从被调函数返回到主调函数中

数据类型 *函数名(参数表){函数体}；

函数返回数组指针

  eg.1 typedef int arr[ ]; arr * fun( int i );

  eg.2 int ( *fun ( int i ) )[ ];

  eg.3 auto fun( int i ) -&gt; int( * )[ ]; //尾置返回类型

  eg.4 decltype( a ) *fun( int ); //返回值类型和a数组相同
</code></pre></blockquote><blockquote><p><strong>指向函数的指针</strong></p><pre><code>执行程序的代码也会被调入内存并占据一定的空间

函数名就表示函数的代码在内存中的起始地址

调用函数的通常形式的实质就是函数代码首地址

函数指针

  函数指针是专门用来存放函数代码首地址的变量

  数据类型 ( * 函数指针名) (形参表)；

  函数指针使用前需要赋值，指向一个存在的函数代码起始地址
</code></pre></blockquote><blockquote><p><strong>对象指针</strong></p><pre><code>  每个对象在初始化之后都会在内存中占有一定的空间

  对象指针就是用于存放对象地址的变量

  一般的对象指针

    声明的语法形式 类名 *对象指针名；

    对象指针可以方便地访问对象的成员

    对象指针名 -&gt; 成员名

    ( * 对象指针名).成员名

  this指针(类似python中self)

    隐含于类非静态成员函数的特殊指针，是常量型指针

    this指针指向正被成员函数操作的对象

    this指针是成员函数的一个隐含形参

  指向类非静态成员的指针

    类的成员自身也可以被存放道一个指针变量中，进而通过指针访问成员

    数据成员 类型说明符 类名 :: *指针名;

    函数成员 类型说明符 (类名 :: *指针名)(参数表);

    对类中成员取地址时也需要遵循访问权限约定(&amp;类名::成员名)

    通过指针访问类的成员

      对象名.*数据成员指针名/(对象名.*函数成员指针名)(参数表)

      对象指针名-&gt;*数据成员指针名/(对象指针名-&gt;函数成员指针名)(参数表)

    指向类静态成员的指针

      对类静态成员的访问不依赖对象，可以用普通指针
</code></pre></blockquote><p><strong>动态内存分配</strong></p><blockquote><p>动态内存分配即在运行过程中按照实际申请适量内存，试用结束后释放</p><p>这种在程序运行过程中申请和释放的存储单元也称为堆对象</p><p>申请和释放过程一般称为建立和删除，使用new和delete运算符</p></blockquote><blockquote><p><strong>new运算符</strong></p><pre><code>动态创建堆对象 new 数据类型(初始化参数列表)

如果内存申请成功，new运算便返回一个指向新分配内存首地址的指针

如果申请失败会抛出异常

建立基本类型对象

  初始化过程即为赋值 int *p=new int(2)

  如果不希望设定初始值可以省去括号 int *p=new int

  如果保留括号但不写值，默认用0初始化

建立类的实例对象

  根据初始化参数列表(参数类型和个数)调用类的构造函数

  若类存在用户定义的默认构造函数，则new T和new T()等效

  若用户未定义，则new T()会默认为基本类型和指针类型成员赋0值
</code></pre></blockquote><blockquote><p><strong>delete运算符</strong></p><pre><code>用来删除由new建立的对象，释放指针所指向的内存空间 delete 指针名;

如果被删除的是实例对象，对象的析构函数将被调用

new建立的对象只能使用delete一次，多次删除会导致错误

用new分配的内存必须用delete释放，否则会导致&quot;内存泄露&quot;
</code></pre></blockquote><p><strong>vector创建数组</strong></p><blockquote><p>静态数组和new动态创建数组难以检测下标越界的错误</p><p>Cpp标准库提供了被封装的动态数组&mdash;&mdash;vector，它是一个类模板</p><p><strong>vector&lt;元素类型>数组对象名(数组长度,元素初值)；</strong>//数组长度可含变量</p><p>vector定义的数组对象所有元素都会被初始化，若无元素初值默认赋0</p><p>vector数组对象是分装数组类的实例，用下标访问元素，但对象名不为首地址</p><p>数组对象数组对象名.size( ) 可返回数组大小</p><p>更多特性在类模板一章中介绍</p></blockquote><p><strong>深层复制与浅层复制</strong></p><blockquote><p><strong>浅层复制</strong></p><pre><code>实现数据项的复制(值复制)，指针变量也会指向同一地址

在释放动态内存空间时可能会delete一处地址多次
</code></pre></blockquote><blockquote><p><strong>深层复制</strong></p><pre><code>编写构造函数使得指针指向新地址，形成真正的副本
</code></pre></blockquote><p><strong>字符串</strong></p><blockquote><p><strong>用字符数组存储和处理字符串</strong></p><pre><code>字符串常量是一个隐含创建的char数组，字符串常量表示数组的首地址

可以将字符串常量赋给常量字符串指针

字符串变量也可以用类似方式来表示，将元素放入char数组，末尾放置一个 '\0'

char数组需使用strcpy(复制)，strcmp(排序)，strcat(拼接)等函数处理字符串
</code></pre></blockquote><blockquote><p><strong>string类</strong></p><pre><code>Cpp中预定义了字符串类，提供了对字符串进行处理所需要的操作

使用string类需要包含头文件string，封装了串的属性和一系列访问属性的函数

构造函数

  string( ) //建立长度为0的串

  string(const string &amp;rhs) //复制构造函数

  string(const char *s) //用指针s指向的字符串常量初始化string对象

  string(const string &amp;rhs ,unsigned int pos ,unsigned int);

    //将对象rhs中的字符串从pos往后取n个字符初始化string对象

  string(const char *s ,unsigned int n);

    //用指针s指向的字符串前n个字符初始化string对象

  string(unsigned int n ,char c); //将c字符重复你次初始化string对象

string类的操作符

  方便地完成字符串复制、字符串链接、字符串比较等功能

  字符串比较是按照字典序比较

常用成员函数功能

  append(const char *s); //将字符串s添加在本串尾

  assign(const chae *s); //将s指向的字符串赋值给本对象

  compare(const string &amp;str) ; //比较本串与str串大小，小于负数大于正数

  insert(unsigned int pos ,const char *s); //将s指向的字符串插在pos之前

  substr(unsigned int pos ,unsigned int n) ; //取本串pos后的n个字符做子串

  find(const basic_string &amp;str); //查找并返回str在本串第一次出现的位置

  length( ); //返回串的长度(字符个数)

  swap(string &amp; str); //将本串与str中的字符串进行交换
</code></pre></blockquote><p><strong>*指针与引用</strong></p><blockquote><p>引用和指针常量使用形式的对比</p><p>引用运行的实现机制最终不得不借助地址，二者殊途同归</p><p><strong>引用只能在初始化时指定被引用的对象，类似于指针常量</strong></p><p><strong>引用不可以再被取地址</strong>，引用一经定义本身占据的空间被完全隐藏</p><p>引用可以更加方便安全地实现数据双向传递等简单需求</p></blockquote><p><strong>*reinterpret_cast</strong></p><blockquote><p><strong>可以将一种类型的指针转换成另一种类型的指针</strong></p><p>可以在不同类型对象、函数，类函数、数据成员成员之间转换</p><p><strong>有很大的危险性和不确定性</strong></p></blockquote><p><strong>*const_cast</strong></p><blockquote><p><strong>将数据类型中const属性去除</strong></p><p>在某些固定场合适当地使用它可以是安全的</p></blockquote><ul class=pa0></ul><div class="mt6 instapaper_ignoref"></div></div><aside class="w-30-l mt6-l"></aside></article></main><footer class="bg-black bottom-0 w-100 pa3" role=contentinfo><div class="flex justify-between"><a class="f4 fw4 hover-white white-70 dn dib-ns pv2 ph3 no-underline" href=https://wrongtrojan.github.io/>&copy; 一个分享学习笔记的网站 2025</a><div><div class=ananke-socials></div></div></div></footer></body></html>