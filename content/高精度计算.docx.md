+++
title = "高精度计算"
date = 2025-11-24
draft = false
categories=["数据结构与算法"]
+++
<!--more-->
**高精度计算**

高精度计算(High-Precision Calculation)通过自定义存储和模拟手工运算实现计算

**核心问题**

>   常规数据类型的范围有限,处理更大的数时，常规类型会发生溢出

**数据存储方式**

>   高精度计算的核心是用字符串或数组存储大整数,两种方式各有优势

>     -----------------------------------------------------------------------
>     存储方式         优势                    适用场景
>
>     字符串           直接输入，便于输出       输入输出频繁、需直接处理字符的场景
>
>     动态数组         访问效率高，便于运算     运算密集型场景（如乘法、除法）
>     ------------------------------------------------------------------------

>   **存储细节**
>
>     顺序 通常按低位在前，高位在后存储，方便从低位开始处理进位/借位；
>
>     正负号 用单独的标志位存储符号，数值部分仅存绝对值
>
>     前导零 存储时需去除前导零，避免运算错误。

**核心运算实现（以非负整数为例）**

>   **高精度加法(A+B)**
>
>     核心逻辑 从低位到高位逐位相加，累加进位，最终合并结果。
>
>     步骤
>
>       反转A和B（使低位在前）
>
>       初始化进位carry=0，遍历两数的每一位
>
>       当前位总和 = A[i]的数值 + B[i]的数值 + carry
>
>         结果当前位 = 总和 % 10
>
>         新进位 = 总和 / 10
>
>       遍历结束后，若仍有进位(carry>0)，将进位添加到结果
>
>       反转结果，得到最终答案

>   **高精度减法（A-B，需A\>=B）**
>
>       核心逻辑  从低位到高位逐位相减，处理借位(若当前位A[i]<B[i]，则借位)
>
>       步骤
>
>         先判断A≥B（位数多则大；位数相同则逐位比较）
>
>         反转A和B，初始化借位borrow = 0，遍历每一位
>
>           当前位A[i]的数值 = 原数值 - borrow（减去上一位的借位）
>
>           若A[i]<B[i]，则A[i]+=10，同时borrow=1（向高位借位）
>
>           结果当前位=A[i]-B[i]
>
>         反转结果，去除前导零。
>

>   **高精度乘法（A\*B）**
>
>       核心逻辑 逐位相乘后累加，利用数组存储中间结果，最后处理进位。
>
>       步骤
>
>         若A或B为"0"，直接返回"0"
>
>         初始化结果数组resArr(长度为A.size()+B.size())
>
>         遍历A的每一位和B的每一位（从低位到高位）
>
>           乘积 = A[i]的数值*B[j]的数值
>
>           累加至resArr[i+j+1](当前位),并将进位累加到resArr[i+j]
>
>           处理数组中的进位（每一位超过 10 则向高位进位）
>
>         将数组转换为字符串，去除前导零。
>


>   **高精度除法（A/B）**
>
>     高精度除法分两种场景，实现难度差异较大：

>     ---------------------------------------------------
>     场景             难度       核心逻辑
>
>     高精度/低精度     简单       从高到低逐位试商，保留余数
>
>     高精度/高精度     复杂       用减法模拟除法或二分法
>     ----------------------------------------------------


>   **处理正负号**
>
>     上述运算仅支持非负整数，若需处理负数，需增加符号逻辑
>
>     用标志位（如bool negA = (a[0] == '-')）记录A和B的符号
>
>     提取绝对值部分（如a = a.substr(1)）进行运算
>
>     根据符号和运算类型确定结果符号
