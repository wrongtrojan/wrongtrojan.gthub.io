+++
title = "6.数组、指针与字符串"
weight=6
date = 2025-11-24
draft = false
categories=["程序设计"]
+++
<!--more-->
**数组、指针与字符串**

**数组**

>   具有一定顺序关系的对象集合体，组成数组的对象是数组的元素
>
>   每个元素有n个下标的数组称为n维数组

>   **数组的声明**
>
>     数据类型 标识符[][]...[];

>   **数组的使用**
>
>     通过下标来访问数组中的元素(下标必须为整数且不得越界)

>   **数组的存储**
>
>     数组元素在内存中是顺序、连续存储的(包括多维数组)

>   **数组的初始化**
>
>     在声明数组时给部分或全部元素赋初值
>
>     如果列出全部元素初值，可以不做元素个数说明
>
>     多维数组可以按第一维进行分组，用括号将每一组括起来
>
>     数组也可以被声明为常量

>   **数组作为函数参数**
>
>     使用数组名传递数据时，传递的是地址
>
>     形参数组和实参数组的首地址重合，后面元素各自对应

>   **对象数组**
>
>     数组的元素也可以是自定义类型
>
>     通过对象数组[下标].member可以访问公共成员

**指针**

>   **内存空间的访问方式**
>
>     计算机的内存储器被划分为存储单元按一定规则编号，即为地址
>
>     地址编码的最基本单位是字节，每字节由8个二进制位组成
>
>     Cpp程序中通过变量名和地址利用内存单元存取数据
>
>     不传递变量的值，只传递变量得地址可以减小系统开销

>   **指针变量的声明**
>
>     指针变量是用于存放内存单元地址的
>
>     数据类型 *标识符(这里的*表征声明指针);
>
>     指针可以指向各种类型，包括基本类型、数组(数组元素)、函数、对象、指针

>   **与地址相关的运算 "\*" and "&"**
>
>     "*" 指针运算符(解析运算符)
>
>       表示获取指针所指向的变量的值，是一元操作符
>
>     "&" 取地址运算符
>
>       得到一个对象的地址，也是一元运算符
>
>     * "&"出现在变量声明左边时，表示声明引用；
>
>       出现在等号右边或执行语句时表示取地址

>   **指针的赋值**
>
>     定义指针时进行初始化赋值，或者定义后单独使用赋值语句
>
>     多个指针可以指向同一个变量，一个指针只能指向一个变量
>
>     数组名称实际上是一个不能赋值的指针常量
>
>     指向常量的指针
>
>       const 类型 \*p;
>
>       指针指向的值不能通过指针改变，但指针本身可以改变指向另一个对象
>
>     指针类型的常量
>
>       类型 \* const p;
>
>       指针本身的值不能改变，指向某个固定的对象
>
>       一般指针的值只能赋给同类型指针，但void类型可以储存任何类型对象地址
>
>       void指针一般只在指针指向对象不确定时使用

>   **指针运算**
>
>     指针是一种数据类型，可以参与部分运算(算术运算、关系运算和赋值运算)
>
>     算术运算
>
>       指针可以和整数做加减法运算，表达指针指向位置后移或前移
>
>       如(pl+nl)(或pl\[nl\])表示pl指向位置后移nl个数(nl\*typebyte个字节)
>
>       一般指针的算术运算和数组使用相联系，避免破坏地址数据或代码
>
>     关系运算
>
>       指向相同类型数据的指针之间进行的关系运算
>
>       两个指针相等，表示两个指针指向同一个地址
>
>       指针变量可以和整数0进行比较，0专用于表示空指针
>
>       空指针不指向任何有效地址

>   **用指针处理数组元素**
>
>     begin和end
>
>       begin返回指向数组首元素的指针
>
>       end返回返回指向数组尾元素下一元素的指针
>
>       这两个函数定义在iterator头文件

>   **指针数组**
>
>     元素都是指针变量的数组，每个元素必须是同一类型的指针
>
>     数据类型 \*pa\[下标\]；
>
>     可以用数组初始化指针数组，元素为数组首地址

>   **指针作为函数参数**
>
>     在不同函数之间传递大量数据时程序开销非常大
>
>     如果传递数据存放在连续内存区域中，可以只传递数据的起始地址
>
>     指针作为函数的形参有三个作用
>
>       使实参与形参指向共同内存空间，达到参数双向传递
>
>       减少函数调用时数据传递的开销(一般会使用引用，部分使用指针)
>
>       通过指向函数的指针传递函数代码的首地址

>   **指针型函数**
>
>     指针也可以是函数的返回值，返回值为指针的函数即为指针型函数
>
>     在函数结束时把大量的数据从被调函数返回到主调函数中
>
>     数据类型 *函数名(参数表){函数体}；
>
>     函数返回数组指针
>
>       eg.1 typedef int arr[ ]; arr * fun( int i );
>
>       eg.2 int ( *fun ( int i ) )[ ];
>
>       eg.3 auto fun( int i ) -> int( * )[ ]; //尾置返回类型
>
>       eg.4 decltype( a ) *fun( int ); //返回值类型和a数组相同

>   **指向函数的指针**
>
>     执行程序的代码也会被调入内存并占据一定的空间
>
>     函数名就表示函数的代码在内存中的起始地址
>
>     调用函数的通常形式的实质就是函数代码首地址
>
>     函数指针
>
>       函数指针是专门用来存放函数代码首地址的变量
>
>       数据类型 ( * 函数指针名) (形参表)；
>
>       函数指针使用前需要赋值，指向一个存在的函数代码起始地址

>    **对象指针**
>
>       每个对象在初始化之后都会在内存中占有一定的空间
>
>       对象指针就是用于存放对象地址的变量
>
>       一般的对象指针
>
>         声明的语法形式 类名 *对象指针名；
>
>         对象指针可以方便地访问对象的成员
>
>         对象指针名 -> 成员名
>
>         ( * 对象指针名).成员名
>
>       this指针(类似python中self)
>
>         隐含于类非静态成员函数的特殊指针，是常量型指针
>
>         this指针指向正被成员函数操作的对象
>
>         this指针是成员函数的一个隐含形参
>
>       指向类非静态成员的指针
>
>         类的成员自身也可以被存放道一个指针变量中，进而通过指针访问成员
>
>         数据成员 类型说明符 类名 :: *指针名;
>
>         函数成员 类型说明符 (类名 :: *指针名)(参数表);
>
>         对类中成员取地址时也需要遵循访问权限约定(&类名::成员名)
>
>         通过指针访问类的成员
>
>           对象名.*数据成员指针名/(对象名.*函数成员指针名)(参数表)
>
>           对象指针名->*数据成员指针名/(对象指针名->函数成员指针名)(参数表)
>
>         指向类静态成员的指针
>
>           对类静态成员的访问不依赖对象，可以用普通指针

**动态内存分配**

>   动态内存分配即在运行过程中按照实际申请适量内存，试用结束后释放
>
>   这种在程序运行过程中申请和释放的存储单元也称为堆对象
>
>   申请和释放过程一般称为建立和删除，使用new和delete运算符

>   **new运算符**
>
>     动态创建堆对象 new 数据类型(初始化参数列表)
>
>     如果内存申请成功，new运算便返回一个指向新分配内存首地址的指针
>
>     如果申请失败会抛出异常
>
>     建立基本类型对象
>
>       初始化过程即为赋值 int *p=new int(2)
>
>       如果不希望设定初始值可以省去括号 int *p=new int
>
>       如果保留括号但不写值，默认用0初始化
>
>     建立类的实例对象
>
>       根据初始化参数列表(参数类型和个数)调用类的构造函数
>
>       若类存在用户定义的默认构造函数，则new T和new T()等效
>
>       若用户未定义，则new T()会默认为基本类型和指针类型成员赋0值

>   **delete运算符**
>
>     用来删除由new建立的对象，释放指针所指向的内存空间 delete 指针名;
>
>     如果被删除的是实例对象，对象的析构函数将被调用
>
>     new建立的对象只能使用delete一次，多次删除会导致错误
>
>     用new分配的内存必须用delete释放，否则会导致"内存泄露"

**vector创建数组**

>   静态数组和new动态创建数组难以检测下标越界的错误
>
>   Cpp标准库提供了被封装的动态数组------vector，它是一个类模板
>
>   **vector\<元素类型\>数组对象名(数组长度,元素初值)；**//数组长度可含变量
>
>   vector定义的数组对象所有元素都会被初始化，若无元素初值默认赋0
>
>   vector数组对象是分装数组类的实例，用下标访问元素，但对象名不为首地址
>
>   数组对象数组对象名.size( ) 可返回数组大小
>
>   更多特性在类模板一章中介绍

**深层复制与浅层复制**

>   **浅层复制** 
>
>     实现数据项的复制(值复制)，指针变量也会指向同一地址
>
>     在释放动态内存空间时可能会delete一处地址多次

>   **深层复制**
>
>     编写构造函数使得指针指向新地址，形成真正的副本

**字符串**

>   **用字符数组存储和处理字符串**
>
>     字符串常量是一个隐含创建的char数组，字符串常量表示数组的首地址
>
>     可以将字符串常量赋给常量字符串指针
>
>     字符串变量也可以用类似方式来表示，将元素放入char数组，末尾放置一个 '\0'
>
>     char数组需使用strcpy(复制)，strcmp(排序)，strcat(拼接)等函数处理字符串

>   **string类**
>
>     Cpp中预定义了字符串类，提供了对字符串进行处理所需要的操作
>
>     使用string类需要包含头文件string，封装了串的属性和一系列访问属性的函数
>
>     构造函数
>
>       string( ) //建立长度为0的串
>
>       string(const string &rhs) //复制构造函数
>
>       string(const char *s) //用指针s指向的字符串常量初始化string对象
>
>       string(const string &rhs ,unsigned int pos ,unsigned int);
>
>         //将对象rhs中的字符串从pos往后取n个字符初始化string对象
>
>       string(const char *s ,unsigned int n);
>
>         //用指针s指向的字符串前n个字符初始化string对象
>
>       string(unsigned int n ,char c); //将c字符重复你次初始化string对象
>
>     string类的操作符
>
>       方便地完成字符串复制、字符串链接、字符串比较等功能
>
>       字符串比较是按照字典序比较
>
>     常用成员函数功能
>
>       append(const char *s); //将字符串s添加在本串尾
>
>       assign(const chae *s); //将s指向的字符串赋值给本对象
>
>       compare(const string &str) ; //比较本串与str串大小，小于负数大于正数
>
>       insert(unsigned int pos ,const char *s); //将s指向的字符串插在pos之前
>
>       substr(unsigned int pos ,unsigned int n) ; //取本串pos后的n个字符做子串
>
>       find(const basic_string &str); //查找并返回str在本串第一次出现的位置
>
>       length( ); //返回串的长度(字符个数)
>
>       swap(string & str); //将本串与str中的字符串进行交换

**\*指针与引用**

>   引用和指针常量使用形式的对比
>
>   引用运行的实现机制最终不得不借助地址，二者殊途同归
>
>   **引用只能在初始化时指定被引用的对象，类似于指针常量**
>
>   **引用不可以再被取地址**，引用一经定义本身占据的空间被完全隐藏
>
>   引用可以更加方便安全地实现数据双向传递等简单需求

**\*reinterpret_cast**

>   **可以将一种类型的指针转换成另一种类型的指针**
>
>   可以在不同类型对象、函数，类函数、数据成员成员之间转换
>
>   **有很大的危险性和不确定性**

**\*const_cast**

>   **将数据类型中const属性去除**
>
>   在某些固定场合适当地使用它可以是安全的

