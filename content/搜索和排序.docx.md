+++
title = "搜索和排序"
weight= 5
date = 2025-11-24
draft = false
categories=["数据结构与算法"]
+++
<!--more-->
**搜索和排序**

**搜索**

>   **顺序搜索**
>
>       顺序搜索算法的时间复杂度为O(N^2)

>   **二分搜素**
>
>       如果列表有序可采用二分搜索
>
>       二分搜索算法的时间复杂度为O(logN)

>   **散列**
>
>       散列表
>
>           元素集合，储存在槽中便于查找
>
>       载荷因子
>
>           槽的占用率称为载荷因子
>
>       散列函数
>
>           散列函数将散列表中的元素与其所属位置对应起来，常常是取余函数
>
>           完美散列函数
>
>               给定一个元素集合将每个元素映射到不同的槽
>
>           扩展取余函数的方法
>
>               折叠法
>
>                   将元素切成等长的部分然后相加再求散列值
>
>               平方取中法
>
>                   先将元素取平方，然后提取中间几位数求散列值
>
>           散列函数一定要高效，避免成为存储和搜索的负担
>
>       冲突
>
>           散列函数将两个元素都放入同一个槽
>
>           处理冲突
>
>               通过系统化方法在散列表中安置冲突的第二个元素
>
>               开放地址法
>
>                   线性探测
>
>                       在散列表寻找下一个空槽或地址
>
>                       容易造成散列表元素出现聚集现象
>
>                   平方探测
>
>                       线性探测的变体，不采用固定的跨步大小
>
>               链接法
>
>                   允许散列表中的同一个元素上存在多个元素。
>
>                   发生冲突时元素仍然被插入其散列值对应的槽中。
>
>                   随着同一个位置上的元素越来越多，搜索变得越来越困难

**排序**

>   **冒泡排序O(N^2)**
>
>       每一轮遍历都将下一个最大值放到正确的位置上
>
>       如果在一轮遍历中没有发生元素交换，就可以确定已经有序，使其提前终止

>   **选择排序O(N^2)**
>
>       每次遍历列表时只做一次交换，每次遍历只交换一次

>   **插入排序O(N^2)**
>
>       在列表较低的一端维护有序的子列表，并逐个将每个新元素"插入"子列表

>   **希尔排序\[可以到达O(N^3/2)\]**
>
>       将列表分成数个子列表，并对每一个子列表应用插入排序
>
>       切分列表是希尔排序的关键，并非连续切分，使用增量i切分列表

>   **归并排序**
>
>       分支策略改进排序算法，归并排序是递归算法
>
>       基准情形 如果列表为空或者只有一个元素，那么有序
>
>       不断演进 列表一分为二两部分递归调用分别排序

>   **快速排序O(NlogN)\[有可能退化\]**
>
>       也采用分治策略，但不使用额外的存储空间
>
>       首先选出基准值（多种方法，尽量均匀分割）
>
>           帮助切分列表，基准值的最终的位置是分割点
>
>       接着进行分区（若左小右大）
>
>           左指针找到比基准大的，右指针找到比基准小的，两者交换
>
>       若右指针小于左指针
>
>           右指针即为分割点
>
>       递归调用该过程
