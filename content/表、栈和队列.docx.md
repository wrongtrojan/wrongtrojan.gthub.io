**列表、栈和队列**

**抽象数据类型(abstract data type)**

> ADT是一些操作的集合，可以有诸如并、交、测定大小、取余、查找等操作
>
> **列表(List)ADT**
>
> **列表模型**
>
> 元素的集合，每一个元素有其相对位置
>
> 支持操作 add() remove() search isEmpty() length() index()
>
> append() insert(pos,item) pop() pop(pos)
>
> **列表的数组实现**
>
> 插入和删除的运行时间复杂度高，表的大小必须事先已知
>
> **链表(linked list)（允许表不连续存储）**
>
> 链表的每个节点均含有数据域和指向后继节点的指针域（Next指针）
>
> 最后一个节点的Next指针指向NULL（0）
>
> 留出一个标志节点，称为表头(header)或哑结点(dummy node)
>
> Delete可以通过修改指向待删除节点指针，使之指向下一节点实现
>
> **双链表(double linked list)（允许双向扫描链表）**
>
> 在链表节点结构上附加一个域，使节点包含指向上一个节点的指针
>
> 增加了空间需求，使插入和删除的开销增加一倍，但简化了删除操作
>
> **循环链表**
>
> 最后节点反过来直指第一个节点
>
> **链表的应用**
>
> 基数排序(radix sort)
>
> **栈(stack)ADT**
>
> **栈模型**
>
> 限制插入（进栈）和删除（出栈）只在栈顶进行的表，又称为FILO表
>
> 支持操作 push() pop() peak()~(返回栈顶）~ isEmpty() size()
>
> **栈的链表实现**
>
> 操作指针的例程开销昂贵
>
> **栈的数组实现**
>
> **栈的应用（反转特性）**
>
> 匹配括号
>
> 进制转化
>
> 前、中、后序表达式转化

**队列(queue)ADT**

> **队列模型**
>
> 在队尾(rear)插入（入队），在队头(front)删除（出队）的表，又称FIFO表
>
> 支持操作 enqueue() dequeue() isEmpty() size()
>
> **队列的数组实现**
>
> 通过循环数组(circular array)实现
>
> **队列的应用**
>
> 模拟：约瑟夫问题
>
> 模拟：打印任务

**双端队列(deque)ADT**

> 同时具备栈和队列的特性
>
> **双端队列的应用**
>
> 回文检测器
