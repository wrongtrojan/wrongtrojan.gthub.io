+++
title = "优先队列"
weight= 7
date = 2025-11-24
draft = false
categories=["数据结构与算法"]
+++
<!--more-->
**优先队列(堆)**

**模型**

>   **优先队列至少允许的操作**
>
>       Insert( ) 插入元素
>
>       DeleteMIn( ) 找出、返回和删除优先队列的最小元素

>   **其他扩展操作**
>
>       FindMIn( ) 返回最小元素，元素留在堆中
>
>       isEmpty( ) 判断堆是否为空
>
>       size( ) 返回堆中元素个数
>
>       buildHeap() 根据关键字创建堆
>
>       *若能直到关键字的具体位置
>
>       DecreaseKey( ) 降低关键字的值
>
>       IncreaseKey( ) 增加关键字的值

**简单实现**

>   **使用简单链表**
>
>       O(1)执行插入操作
>
>       O(N)执行删除最小元

>   **使用有序表**
>
>       O(N)执行插入操作
>
>       O(1)执行删除最小元

>   **使用二叉查找树**
>
>       两者操作平均运行时间均为O(logN)
>
>       通过使用平衡树可以避免退化成链表
>
>       有许多冗余操作

**二叉堆(binary heap)**

>   **结构性质**
>
>       堆是一颗完全二叉树，非底层全填满，底层元素从左到右填入
>
>       为节点从1依次编号，完全二叉树可以由一个数组来表示
>
>       对节点i，其左子节点为2i，右子节点为2i+1，父节点为\[i/2\]
>
>       若使用数组，最大的堆大小需要事先估计

>   **堆序性质**
>
>       堆序性是使操作被快速执行的性质，也即最小元应该在根上
>
>       考虑任意子树也应该是堆，任意节点应该小于所有后裔
>
>   **基础操作的实现**
>
>       Insert( ) 采取(新元素)上浮
>
>           新元素加入堆末尾，与父节点比较并交换直到大于父节点
>
>       DeleteMin( ) 采取(末元素)下沉
>
>           删除根节点后，堆末元素填入空穴
>
>           与子节点比较，若比子节点小，则与更小子节点交换
>
>           直到比两个子节点都小停止

>   **其他堆操作的实现**
>
>       DcreaseKey( ) 采取上浮操作
>
>       IncreaseKey( ) 采取下沉操作
>
>       其余操作同树的实现类似

**d-堆**

>   d-堆是二叉堆的简单推广，所有的节点都有d个儿子
>
>   若d不为2的幂，则使用数组储存后运行时间大幅增加
>
>   在插入次数比删除次数多得多时以及二叉堆太大时d-堆较为实用

**左式堆(leftist heap)**

>   具有一定二叉堆特性的同时高效支持合并操作

>   **左式堆的性质**
>
>       零路径长(null path length NPL)
>
>           节点到没有两个子节点的节点的最短路径长
>
>           具有0或1个子节点的节点Npl为0，Npl(NULL)=-1
>
>       左式堆结构性
>
>           堆中每一个节点，左子节点零路径长\>=右子节点零路径长
>
>           在右路径上右r个节点的左式堆至少有2^r^-1个节点
>
>       左式堆堆序性
>
>           与二叉堆相同

>   **左式堆的操作**
>
>       左式堆的操作的一般思路式将所有工作放在右路径进行
>
>       基本操作(合并Merge)
>
>           插入可以看作单节点堆与大堆合并
>
>           递归形成
>
>           基准情形 如果两堆有一个是空的，则返回非空的
>
>           不断演进(假设root(H1)\<root(H2))
>
>               H1右子堆加入H2右子堆，新H2作为H1新右子堆
>
>               若H1左右子堆不满足堆序则交换，然后更新零路径长

**斜堆(skew heap)**

>   斜堆具有堆序但不存在对树的结构限制
>
>   任意M次连续操作，总最坏情形运行时间是O(MlogN)
>   
>   除右路径上所有节点最大者不交换外，其他节点无条件交换左右子堆

**二项队列(binomial queue)**

>   **二项队列结构**
>
>       二项队列是堆序树的集合，是森林
>
>       堆序树中的每一颗都是二项树(节点数为2的幂)
>
>       高度为k的二项树恰好有2^K^个节点，深度为d的节点数是二项系数(k/d)

>   **二项队列操作**
>
>       二项队列合并可以类比二进制数的加法

>   **二项队列实现**
>
>       每个节点的子节点都存在一个链表中
>
>       每个节点都有指向第一个子节点的指针
