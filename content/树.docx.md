+++
title = "树"
weight= 6
date = 2025-11-24
draft = false
categories=["数据结构与算法"]
+++
<!--more-->
**树**

**树相关术语**

>   **节点**
>
>       节点可以有自己的名字"键"，也可以附带信息称作"有效载荷"
>
>       根节点 唯一没有入边的节点
>
>       子节点 一个节点通过边与子节点相连
>
>       父节点 一个节点时所有子节点的父节点
>
>       兄弟节点 具有同一个父节点的节点互称为兄弟节点
>
>       叶节点 叶节点没有子节点

>   **边**
>
>       两个节点通过一条边相连，表示它们之间存在关系
>
>       除根节点外其他每个节点仅有一条入边，出边则可能有多条

>   **路径**
>
>       由边连接的有序节点列表

>   **子树**
>
>       一个父节点以及其所有后代的节点和边构成一颗子树

>   **层数**
>
>       节点n的层数是根节点到n的唯一路径长度

>   **高度**
>
>       树的高度是其中节点层数的最大值

**树的定义**

>   **节点与边**
>
>       有一个根节点
>
>       除根节点外其他每个节点由与唯一的父节点相连
>
>       从根节点到其他每个节点都有且只有一条路径
>
>       如果每个节点最多有两个子节点，称之为二叉树

>   **递归定义**
>
>       一棵树要么为空要么由一个根节点和零棵或多颗子树构成
>
>       每颗子树的根节点通过一条边连到父树的根节点

**树的实现**

>   **嵌套列表(python)**

>   **节点与指针**

>       每个节点的所有子节点放在树节点的链表中
>
>       节点的指针可以指向兄弟或儿子

**树的遍历**

>   **前序遍历**
>
>       先访问根节点，然后递归地前序遍历左子树，最后递归地前序遍历右子树

>   **中序遍历**
>
>       先递归地中序地遍历左子树，然后访问根节点，最后递归地中序遍历右子树

>   **后序遍历**
>
>       先递归的后续遍历右子树，然后递归地后序遍历左子树，最后访问根节点

**二叉树的操作**

>   getLeftChild( ) 返回当前节点的左子节点对应二叉树
>
>   getRightChild( ) 返回当前节点的右子节点对应二叉树
>
>   setRootVal(val) 在当前节点储存val对象
>
>   getRootVal( ) 返回当前节点存储的对象
>
>   insertLeft(val) 新建当前节点的左子节点
>
>   insertRight(val) 新建当前节点的右子节点

**二叉搜索树(binary tree)**

>   **依赖于二叉搜索性**：所有小于父节点键在左子树，所有大于父节点键在右子树

>   **搜索树的操作**
>
>       Map( ) 新建一个空映射
>
>       put(key,val) 往映射中加入新键值对
>
>       get(key) 返回key对应的值，如果key不存在返回None
>
>       del 从映射中删除键值对
>
>       len( ) 返回映射中储存的键值对数目
>
>       in 在键存在时返回True，否则返回False

>   **搜索树的实现**
>
>       通过TreeNode类提供辅助函数简化BinarySearchTree类的工作
>
>       TreeNode类显式地将每个节点的父节点记录为它的属性

>   **搜索树的分析**
>
>       如果键的插入顺序时随机的，则为O(logN)时间复杂度
>
>       但若按顺序插入键，会使搜索树退化成链表，时间复杂度为O(N)

**平衡二叉搜索树(AVL树)**

>   **带有平衡条件的二叉查找树**，保证树的高度是O(logN)
>
>   每个节点的左子树和右子树的高度最多差一的二叉查找树
>
>   插入一个节点可能破坏AVL树的特性，需要通过旋转来修正

>   **单旋转**
>
>       当插入发生在外侧(左-左，右-右)时通过对树做一次单旋转来调整
>
>       左子树更高时进行右旋转，右子树更高时进行左旋转
>
>       旋转轴是失衡节点导致失衡一侧的子节点

>   **双旋转**
>
>       当插入发生内测(左-右，右-左)时通过对树做一次双旋转来调整
>
>       绕失衡节点失衡一侧孙子节点做失衡方向单旋转，再绕同节点做反方向单旋转

**伸展树(splay tree)**

>   保证从空树开始任意连续M次对树的操作最多花费O(MlogN)时间
>
>   伸展树的基本想法是：当节点被访问后，就经历一系列旋转放到根上

>   **简单想法**
>
>       通过不断做单旋转将访问的节点推向根节点
>
>       这个策略没有明显地改变访问路径其他节点状况

>   **展开(splaying)**
>
>       若访问节点x只有父节点无祖节点，则x-父节点单旋转
>
>       "之"字形(zig-zag/zag-zig)
>
>           x-父节点单旋转
>
>           x-原祖节点单旋转
>
>       "一"字形(zig-zig/zag-zag)
>
>           父节点-祖节点单旋转
>
>           x-父节点单旋转

**B-树**

>   **b-树的结构特性(M阶)**
>
>       树的根或树叶或其子节点数在2和M之间
>
>       除根外，所有非树叶节点的子节点数在\[M/2\]和M之间
>
>       所有的树叶都在相同的深度上
>
>       (b-树有多种定义，有些次要细节不尽相同)
>
>   b-树一般被用于数据库系统
