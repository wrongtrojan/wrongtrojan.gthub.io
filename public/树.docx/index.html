<!DOCTYPE html>
<html lang="zh-cn">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>树 | 一个分享学习笔记的网站</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="">
    <meta name="generator" content="Hugo 0.152.2">
    
    
    
      <meta name="robots" content="noindex, nofollow">
    
    

    
<link rel="stylesheet" href="/ananke/css/main.min.css" >




    


    
      

    

    

    
      <link rel="canonical" href="http://localhost:1313/%E6%A0%91.docx/">
    

    <meta property="og:url" content="http://localhost:1313/%E6%A0%91.docx/">
  <meta property="og:site_name" content="一个分享学习笔记的网站">
  <meta property="og:title" content="树">
  <meta property="og:description" content="Welcome to this website">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:published_time" content="2025-11-24T00:00:00+00:00">
    <meta property="article:modified_time" content="2025-11-24T00:00:00+00:00">

  <meta itemprop="name" content="树">
  <meta itemprop="description" content="Welcome to this website">
  <meta itemprop="datePublished" content="2025-11-24T00:00:00+00:00">
  <meta itemprop="dateModified" content="2025-11-24T00:00:00+00:00">
  <meta itemprop="wordCount" content="119">
  <meta itemprop="keywords" content="数据结构与算法,数据结构与算法">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="树">
  <meta name="twitter:description" content="Welcome to this website">

	
  </head><body class="ma0 avenir bg-near-white development">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l center items-center justify-between">
    <a href="/" class="f3 fw2 hover-white white-90 dib no-underline">
      
        一个分享学习笔记的网站
      
    </a>
    <div class="flex-l items-center">
      

      
        <ul class="pl0 mr3">
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white white-90 no-underline" href="/" title="首页 page">
              首页
            </a>
          </li>
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white white-90 no-underline" href="/about/" title="关于 page">
              关于
            </a>
          </li>
          
        </ul>
      
      <div class="ananke-socials"></div>

    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  
  <article class="flex-l mw8 center ph3 flex-wrap justify-between">
    <header class="mt4 w-100">
      <aside class="instapaper_ignoref b helvetica tracked ttu">
          
        
      </aside><div id="sharing" class="mt3 ananke-socials"></div>
<h1 class="f1 athelas mt3 mb1">树</h1>
      
      
      
      <time class="f6 mv4 dib tracked" datetime="2025-11-24T00:00:00Z">November 24, 2025</time>
      

      
      
    </header>
    <div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-two-thirds-l"><p><strong>树</strong></p>
<p><strong>树相关术语</strong></p>
<blockquote>
<p><strong>节点</strong></p>
<pre><code>  节点可以有自己的名字&quot;键&quot;，也可以附带信息称作&quot;有效载荷&quot;

  根节点 唯一没有入边的节点

  子节点 一个节点通过边与子节点相连

  父节点 一个节点时所有子节点的父节点

  兄弟节点 具有同一个父节点的节点互称为兄弟节点

  叶节点 叶节点没有子节点
</code></pre>
</blockquote>
<blockquote>
<p><strong>边</strong></p>
<pre><code>  两个节点通过一条边相连，表示它们之间存在关系

  除根节点外其他每个节点仅有一条入边，出边则可能有多条
</code></pre>
</blockquote>
<blockquote>
<p><strong>路径</strong></p>
<pre><code>  由边连接的有序节点列表
</code></pre>
</blockquote>
<blockquote>
<p><strong>子树</strong></p>
<pre><code>  一个父节点以及其所有后代的节点和边构成一颗子树
</code></pre>
</blockquote>
<blockquote>
<p><strong>层数</strong></p>
<pre><code>  节点n的层数是根节点到n的唯一路径长度
</code></pre>
</blockquote>
<blockquote>
<p><strong>高度</strong></p>
<pre><code>  树的高度是其中节点层数的最大值
</code></pre>
</blockquote>
<p><strong>树的定义</strong></p>
<blockquote>
<p><strong>节点与边</strong></p>
<pre><code>  有一个根节点

  除根节点外其他每个节点由与唯一的父节点相连

  从根节点到其他每个节点都有且只有一条路径

  如果每个节点最多有两个子节点，称之为二叉树
</code></pre>
</blockquote>
<blockquote>
<p><strong>递归定义</strong></p>
<pre><code>  一棵树要么为空要么由一个根节点和零棵或多颗子树构成

  每颗子树的根节点通过一条边连到父树的根节点
</code></pre>
</blockquote>
<p><strong>树的实现</strong></p>
<blockquote>
<p><strong>嵌套列表(python)</strong></p>
</blockquote>
<blockquote>
<p><strong>节点与指针</strong></p>
</blockquote>
<blockquote>
<pre><code>  每个节点的所有子节点放在树节点的链表中

  节点的指针可以指向兄弟或儿子
</code></pre>
</blockquote>
<p><strong>树的遍历</strong></p>
<blockquote>
<p><strong>前序遍历</strong></p>
<pre><code>  先访问根节点，然后递归地前序遍历左子树，最后递归地前序遍历右子树
</code></pre>
</blockquote>
<blockquote>
<p><strong>中序遍历</strong></p>
<pre><code>  先递归地中序地遍历左子树，然后访问根节点，最后递归地中序遍历右子树
</code></pre>
</blockquote>
<blockquote>
<p><strong>后序遍历</strong></p>
<pre><code>  先递归的后续遍历右子树，然后递归地后序遍历左子树，最后访问根节点
</code></pre>
</blockquote>
<p><strong>二叉树的操作</strong></p>
<blockquote>
<p>getLeftChild( ) 返回当前节点的左子节点对应二叉树</p>
<p>getRightChild( ) 返回当前节点的右子节点对应二叉树</p>
<p>setRootVal(val) 在当前节点储存val对象</p>
<p>getRootVal( ) 返回当前节点存储的对象</p>
<p>insertLeft(val) 新建当前节点的左子节点</p>
<p>insertRight(val) 新建当前节点的右子节点</p>
</blockquote>
<p><strong>二叉搜索树(binary tree)</strong></p>
<blockquote>
<p><strong>依赖于二叉搜索性</strong>：所有小于父节点键在左子树，所有大于父节点键在右子树</p>
</blockquote>
<blockquote>
<p><strong>搜索树的操作</strong></p>
<pre><code>  Map( ) 新建一个空映射

  put(key,val) 往映射中加入新键值对

  get(key) 返回key对应的值，如果key不存在返回None

  del 从映射中删除键值对

  len( ) 返回映射中储存的键值对数目

  in 在键存在时返回True，否则返回False
</code></pre>
</blockquote>
<blockquote>
<p><strong>搜索树的实现</strong></p>
<pre><code>  通过TreeNode类提供辅助函数简化BinarySearchTree类的工作

  TreeNode类显式地将每个节点的父节点记录为它的属性
</code></pre>
</blockquote>
<blockquote>
<p><strong>搜索树的分析</strong></p>
<pre><code>  如果键的插入顺序时随机的，则为O(logN)时间复杂度

  但若按顺序插入键，会使搜索树退化成链表，时间复杂度为O(N)
</code></pre>
</blockquote>
<p><strong>平衡二叉搜索树(AVL树)</strong></p>
<blockquote>
<p><strong>带有平衡条件的二叉查找树</strong>，保证树的高度是O(logN)</p>
<p>每个节点的左子树和右子树的高度最多差一的二叉查找树</p>
<p>插入一个节点可能破坏AVL树的特性，需要通过旋转来修正</p>
</blockquote>
<blockquote>
<p><strong>单旋转</strong></p>
<pre><code>  当插入发生在外侧(左-左，右-右)时通过对树做一次单旋转来调整

  左子树更高时进行右旋转，右子树更高时进行左旋转

  旋转轴是失衡节点导致失衡一侧的子节点
</code></pre>
</blockquote>
<blockquote>
<p><strong>双旋转</strong></p>
<pre><code>  当插入发生内测(左-右，右-左)时通过对树做一次双旋转来调整

  绕失衡节点失衡一侧孙子节点做失衡方向单旋转，再绕同节点做反方向单旋转
</code></pre>
</blockquote>
<p><strong>伸展树(splay tree)</strong></p>
<blockquote>
<p>保证从空树开始任意连续M次对树的操作最多花费O(MlogN)时间</p>
<p>伸展树的基本想法是：当节点被访问后，就经历一系列旋转放到根上</p>
</blockquote>
<blockquote>
<p><strong>简单想法</strong></p>
<pre><code>  通过不断做单旋转将访问的节点推向根节点

  这个策略没有明显地改变访问路径其他节点状况
</code></pre>
</blockquote>
<blockquote>
<p><strong>展开(splaying)</strong></p>
<pre><code>  若访问节点x只有父节点无祖节点，则x-父节点单旋转

  &quot;之&quot;字形(zig-zag/zag-zig)

      x-父节点单旋转

      x-原祖节点单旋转

  &quot;一&quot;字形(zig-zig/zag-zag)

      父节点-祖节点单旋转

      x-父节点单旋转
</code></pre>
</blockquote>
<p><strong>B-树</strong></p>
<blockquote>
<p><strong>b-树的结构特性(M阶)</strong></p>
<pre><code>  树的根或树叶或其子节点数在2和M之间

  除根外，所有非树叶节点的子节点数在\[M/2\]和M之间

  所有的树叶都在相同的深度上

  (b-树有多种定义，有些次要细节不尽相同)
</code></pre>
<p>b-树一般被用于数据库系统</p>
</blockquote><ul class="pa0">
  
</ul>
<div class="mt6 instapaper_ignoref">
      
      
      </div>
    </div>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white white-70 dn dib-ns pv2 ph3 no-underline" href="http://localhost:1313/" >
    &copy;  一个分享学习笔记的网站 2025 
  </a>
    <div><div class="ananke-socials"></div>
</div>
  </div>
</footer>

  </body>
</html>
